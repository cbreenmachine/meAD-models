---
title: "Blood Cell Composition EDA (local)"
author: "Coleman Breen"
date: '2022-08-28'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(methylCC)
library(tidyverse)
library(ExperimentHub)
library(ggsci)

```

# How Does methylCC Output Compared

```{r}
root <- "../../local/dataDerived/"

master.df <- read_csv(file.path(root, "masterSamplesheet.csv")) %>% 
  select(c(sample_id, beadchip_id, diagnostic_group)) %>% 
  drop_na()

sub1.df <- read_csv(file.path(root, "methylBedImputedSubset1/withoutMCI/bloodCellCompositionSubset1.csv"))
sub2.df <- read_csv(file.path(root, "methylBedImputedSubset2/withoutMCI/bloodCellCompositionSubset2.csv"))

whole.df <- rbind(sub1.df, sub2.df) %>% 
  rename(sample_id = sample) %>% 
  arrange(sample_id) %>% 
  filter(!duplicated(sample_id)) %>% 
  pivot_longer(!sample_id, values_to="proportion", names_to = "cell.type") %>% 
  mutate(assay = "WGMS")

whole.df
```



```{r}
array.df <- read_csv(file.path(root, "bloodCellCompositionArray.csv"), show_col_types = FALSE) %>% 
  rename(beadchip_id = patient_id) %>% 
  left_join(master.df, by="beadchip_id") %>% 
  transmute(sample_id, cell.type = cell_type, proportion = methylCC_prop ,assay = "EPIC")

head(array.df)
```


```{r}
df <- master.df %>% select(c(sample_id, diagnostic_group)) %>% 
  full_join(rbind(whole.df, array.df), by=c("sample_id"="sample_id")) %>% 
  pivot_wider(names_from = assay, values_from = proportion) %>% 
  drop_na()
  
```

# Motivation

Short of it is this: methylCC estimates on out 850K data and out EPIC array data do not match.

```{r plot_comparison}
p <- df %>% 
  ggplot(aes(x = EPIC, y = WGMS, color = cell.type)) +
  geom_point() +
  geom_abline(slope = 1, intercept=0, color="grey40", alpha=0.7) +
  facet_wrap(.~diagnostic_group) +
  theme_minimal() +
  ylab("WGBS Platform") +
  xlab("EPIC 850k Platform") +
  labs(caption = 
  "63 samples used. Both estimations use methylCC trained on 450k reference data.\nGray lines represent ideal fit (i.e. perfect concordance)") +
   theme(plot.caption = element_text(hjust = 0),
         plot.background = element_rect(fill="white",
                                        color="white"))

print(p)

cowplot::save_plot(filename="../../figs/2022-08-31-methylCCComparisonStratifiedLOAD-forSK-v2.png", p)

```


# Can EPIC Reference Data Be Used in methylCC?

- First get the better reference data

This section is required in R 4.1.x, but can be skipped if using R 4.2.x (and using the appropriately up-to-date Bioconductor). See the `browseVignettes("FlowSorted.Blood.EPIC")` for more info.


```{r}
hub <- ExperimentHub(cache = "../../dataReference/.cache/ExperimentHub")
query(hub, "FlowSorted.Blood.EPIC")  

FlowSorted.Blood.EPIC <- hub[["EH1136"]]  
FlowSorted.Blood.EPIC  
```


Flow.Sorted.EPIC needs some more processing. Not sure why this isn't part of the function (see https://github.com/stephaniehicks/methylCC/blob/57bf100e2fea1e7c752f36b4253db01a1e9431c7/R/find_dmrs.R#L76), but we need to create our own `mset_train_flow_sort` object.


# Replicate the Internal DMR Hunting without Using methylCC Functions


```{r}

reference <- updateObject(FlowSorted.Blood.EPIC) %>% 
  preprocessIllumina() %>% 
  mapToGenome(mergeManifest = FALSE)

names(pData(reference))

```
Knowing the column names, the first step is to select the cell types. See [here](https://github.com/stephaniehicks/methylCC/blob/57bf100e2fea1e7c752f36b4253db01a1e9431c7/R/find_dmrs.R#L85). We'll skip the "find overlapping regions" since both our real data and this reference data use hg19 EPIC annotation.

```{r}

#Note these are a little different than previously used...
#here we have neutrophils, 450k ref had granulocytes (neu + baso + eorsino[phils])
IDs <- c("CD4T", "CD8T", "Bcell", "NK", "Mono", "Neu")

mset_train_flow_sort <- reference[ , (pData(reference)$CellType %in% IDs)]

```

Now we pull out $\beta$ values, create cell levels. This is just prep to run `bumpHunter()`...

```{r}

pd <- as.data.frame(pData(mset_train_flow_sort))
gr <- granges(mset_train_flow_sort)
p_beta <- getBeta(mset_train_flow_sort, type = "Illumina") # beta values

#Don't think we need to change the sample names as in line 108

cell <- factor(pd$CellType, levels = IDs)
cell_levels <- levels(cell)

```

More extraction to feed into `bumpHunter()`.

```{r}
chr <- as.character(seqnames(gr))
pos <- start(gr)
cl <- clusterMaker(chr, pos) # Create clusters using clusterMaker()

length(unique(cl))
```
500,000 unique clusters against 850,000 positions seems weird...

```{r}

# define design matrix to search for DMRs
xmat = cbind(rep(1, length(cell)), model.matrix(~cell - 1))
colnames(xmat) = c("Intercept", cell_levels)

head(xmat)
```
Why would we want to do pairwise comparisons? Let's stick with the default (not pairwise)

```{r}
all_poss = diag(length(cell_levels))
all_poss <- (all_poss == TRUE)
colnames(all_poss) <- cell_levels

all_poss

```

Agains, the defaults are to use include_dmrs, but not include_cpgs. For clarity and simplicity, I'll just copy the dmr hunting bit.

```{r}
regions_all <- GRanges() 
zmat <- c() # regions_all, will contain all celltype-specific DMRs

bumphunter_beta_cutoff = 0.2
include_dmrs = TRUE
include_cpgs = FALSE

#Defaults
num_cpgs <- 50
num_regions <- 50
dmr_up_cutoff = 0.5
dmr_down_cutoff = 0.4
dmr_pval_cutoff = 1e-11
cpg_pval_cutoff = 1e-08
cpg_up_dm_cutoff = 0
cpg_down_dm_cutoff = 0
```

Giant **** forloop

```{r}
for(ind in seq_len(nrow(all_poss))){
    
    x_ind = cbind("Intercept" = xmat[, "Intercept"],
                  "cellTypes" = rowSums(
                    as.matrix(xmat[, cell_levels[all_poss[ind,]] ],
                              ncols = length(cell_levels[all_poss[ind,]]))))
    
    if(!include_dmrs){ 
      gr_regions_up <- GRanges()
      gr_regions_down <- GRanges()
    }
    
    if(include_dmrs){
      bumps = bumphunter(object = p_beta, design = x_ind, 
                         chr = chr, pos = pos, cluster = cl, 
                         cutoff = bumphunter_beta_cutoff, 
                         B = 0, smooth = FALSE, 
                         smoothFunction = loessByCluster)
      
      # y_regions are the beta values collapsed (CpGs averaged) by regions 
      # from bumphunter
      y_regions <- t(apply(bumps$table[,7:8], 1, function(z){
        colMeans(p_beta[(z[1]):(z[2]),,drop=FALSE]) } ))
      
      tmp <- rowttests(y_regions,factor(x_ind[,"cellTypes"]))
      bumps$table$p.value <- tmp$p.value
      bumps$table$dm <- tmp$dm 
      bumps$table$dmr_up_max_diff <- 
        apply(abs(sweep(y_regions, 2, x_ind[,"cellTypes"], FUN = "-")), 1, max)
      bumps$table$dmr_down_max_diff <- 
        apply(abs(sweep(y_regions, 2, (1 - x_ind[,"cellTypes"]), FUN = "-")), 
              1, max)
      
      # # Only include region with more than 1 CpG (L > 1)
      # #       OR only 1 CpG in region if no other larger regions possible
      L = dm <- NULL 
      keep_ind_regions <- (bumps$table$L > 1 | 
                             (bumps$table$L==1 & bumps$table$clusterL == 1)) & 
        (bumps$table$p.value < dmr_pval_cutoff)  # ideally less than 1e-11
      
      bump_mat_up <- bumps$table[keep_ind_regions & bumps$table$dm < 0 &
                            # ideally less than 0.6
                            bumps$table$dmr_up_max_diff<dmr_up_cutoff,] 
      bump_mat_up <- bump_mat_up[order(-bump_mat_up$L, bump_mat_up$dm), ]
      if(nrow(bump_mat_up) > 0){
        gr_regions_up <- makeGRangesFromDataFrame(bump_mat_up, 
                                                  keep.extra.columns=TRUE)
        mcols(gr_regions_up)$dmr_status <- rep("DMR", length(gr_regions_up))
        gr_regions_up <- gr_regions_up[, names(mcols(gr_regions_up)) %in% 
                              c("indexStart", "indexEnd", "L", "dm", "p.value", 
                                "dmr_status", "dmr_up_max_diff")]
        names(mcols(gr_regions_up))[
          names(mcols(gr_regions_up)) == "dmr_up_max_diff"] <- "dmr_max_diff"

        gr_regions_up <- gr_regions_up %>% arrange(-L, dm) %>% 
                              head(num_regions)
      } else {
        gr_regions_up <- GRanges()
      }
      
      bump_mat_down <- bumps$table[(keep_ind_regions) & bumps$table$dm > 0 & 
                                     bumps$table$dmr_down_max_diff < 
                                     dmr_down_cutoff,] # ideally less than 0.8
      bump_mat_down <- bump_mat_down[order(-bump_mat_down$L, 
                                           -bump_mat_down$dm), ]
      if(nrow(bump_mat_down) > 0){
        gr_regions_down <- makeGRangesFromDataFrame(bump_mat_down, 
                                                    keep.extra.columns=TRUE)
        mcols(gr_regions_down)$dmr_status <- 
                        rep("DMR", length(gr_regions_down))
        gr_regions_down <- gr_regions_down[, names(mcols(gr_regions_down)) %in%
                            c("indexStart", "indexEnd", "L", "dm", "p.value", 
                              "dmr_status", "dmr_down_max_diff")]
        names(mcols(gr_regions_down))[names(mcols(gr_regions_down)) 
                                      == "dmr_down_max_diff"] <- "dmr_max_diff"
        gr_regions_down <- gr_regions_down %>% 
                              arrange(-L, -dm) %>% 
                              head(num_regions)
      } else {
        gr_regions_down <- GRanges()
      }
    }  
    
    if(include_cpgs){
      tstats <- rowttests(p_beta, factor(x_ind[,"cellTypes"]))
      tstats <- tstats[(tstats[, "p.value"] < cpg_pval_cutoff),] 
      
      tstats_up <- tstats[order(tstats[, "dm"], decreasing = FALSE), ]
      # at a min should be less than 0
      tstats_up <- tstats_up[tstats_up$dm < cpg_up_dm_cutoff,] 
        
      probe_keep <- rownames(tstats_up)[seq_len(min(nrow(tstats_up), 
                                                    num_cpgs))]
      if(length(probe_keep) > 0){
        gr_probe <- granges(mset_train_flow_sort[probe_keep,])
        mcols(gr_probe) <- tstats[probe_keep, c("dm", "p.value")]
        mcols(gr_probe)$L <- rep(1, length(probe_keep))
        mcols(gr_probe)$indexStart <- match(probe_keep,
                                            rownames(mset_train_flow_sort))
        mcols(gr_probe)$indexEnd <- match(probe_keep, 
                                          rownames(mset_train_flow_sort))
        mcols(gr_probe)$dmr_status <- rep("CpG", length(gr_probe))
        gr_regions_up <- unique(c(gr_regions_up, 
                                  gr_probe[,c("indexStart", "indexEnd", 
                                              "L", "p.value", "dm", 
                                              "dmr_status")]))
        gr_regions_up <- gr_regions_up %>% arrange(-L, dm) %>% 
                            head(num_regions)
      } 
      
      tstats_down <- tstats[order(tstats[, "dm"], decreasing = TRUE), ]
      # at a min should be greater than 0
      tstats_down <- tstats_down[tstats_down$dm > cpg_down_dm_cutoff,] 
      probe_keep <- rownames(tstats_down)[seq_len(min(nrow(tstats_down), 
                                                      num_cpgs))]
      if(length(probe_keep) > 0){
        gr_probe <- granges(mset_train_flow_sort[probe_keep,])
        mcols(gr_probe) <- tstats[probe_keep, c("dm", "p.value")]
        mcols(gr_probe)$L <- rep(1, length(probe_keep))
        mcols(gr_probe)$indexStart <- match(probe_keep,
                                            rownames(mset_train_flow_sort))
        mcols(gr_probe)$indexEnd <- match(probe_keep, 
                                          rownames(mset_train_flow_sort))
        mcols(gr_probe)$dmr_status <- rep("CpG", length(gr_probe))
        gr_regions_down <- unique(c(gr_regions_down, 
                                    gr_probe[,c("indexStart", "indexEnd", 
                                                "L", "p.value", "dm", 
                                                "dmr_status")]))
        gr_regions_down <- gr_regions_down %>% 
                            arrange(-L, -dm) %>% 
                            head(num_regions)
      } 
    }
    
    mcols(gr_regions_up)$status <- rep("Up", length(gr_regions_up))
    mcols(gr_regions_down)$status <- rep("Down", length(gr_regions_down))
    bump_mat_all <- c(gr_regions_up, gr_regions_down)
    mcols(bump_mat_all)$cellType <- rep(paste(cell_levels[all_poss[ind,]], 
                                              collapse=","), 
                                        length(bump_mat_all)) 
    
    if(length(bump_mat_all) > 0){ 
      regions_all <- c(regions_all, bump_mat_all)
    }
    if(length(gr_regions_up) > 0){
      zmat <- rbind(zmat, t(replicate(min(length(gr_regions_up), num_regions), 
                                      as.numeric(all_poss[ind,]))))
    }
    if(length(gr_regions_down) > 0){
      zmat <- rbind(zmat, t(replicate(min(length(gr_regions_down), 
                                          num_regions), 
                                      as.numeric(!all_poss[ind,]))))
    }
  }
  
```



```{r}
colnames(zmat) <- cell_levels
  
y_regions <- t(apply(
        as.data.frame(mcols(regions_all))[,seq_len(2)],1,function(ind){
  colMeans(p_beta[(ind[1]):(ind[2]),,drop=FALSE])
}))


.splitit <- function(x) {
  split(seq(along = x), x)
}

profiles <- vapply(.splitit(cell), 
                   FUN = function(ind){ rowMeans(y_regions[,ind])}, 
                   FUN.VALUE = numeric(nrow(y_regions)))

removeMe <- duplicated(regions_all)
epic_dmrs <- list(regions_all = regions_all[!removeMe,], 
     zmat = zmat[!removeMe,], 
     y_regions = y_regions[!removeMe,], 
     profiles = profiles[!removeMe,],
     cell = cell, cell_mat = all_poss, 
     cell_levels = cell_levels, pd = pd)

save(list = intersect(ls(), "epic_dmrs"), 
      file = "../../dataReference/epicArrayReferenceForMethylCC.RData")

```


The `out` list should contain everything needed to run. 

# Try It On Our Data


```{r}
load("../../local/dataDerived/genomicMethylSet.RData")
genomic.methylset
```


Run the estimation procedure on *our EPIC data* and reformat to fit in framework from above.

```{r}

est <- methylCC::estimatecc(object=genomic.methylset, find_dmrs_object = out)


array.from.epic.df <- cell_counts(est) %>%
  rownames_to_column("beadchip_id") %>% 
  full_join(master.df, by = "beadchip_id") %>% 
  dplyr::select(-c(beadchip_id)) %>% 
  pivot_longer(cols = -c(sample_id, diagnostic_group), names_to = "cell.type", values_to = "EPIC")

array.from.epic.df

```

Importantly, you need to take the `find_dmrs_object` saved to `../../dataReference` and port to remote. Then run `00-estimateBloodCellProp.R` and pull data from remote.

```{r}
wgms.from.epic.df <- read_csv("../../dataDerived/methylBedImputedSubset1/withoutMCI/bloodCellCompFromEPIC.csv", show_col_types=F) %>% 
  pivot_longer(cols = -sample_id, names_to = "cell.type", values_to = "WGMS")
  

from.epic.df <- full_join(array.from.epic.df, wgms.from.epic.df, by = c("sample_id", "cell.type")) %>% 
  drop_na()
```


```{r}
p <- from.epic.df %>%  
  ggplot(aes(x = EPIC, y = WGMS, color = cell.type)) +
  geom_point() +
  geom_abline(slope = 1, intercept=0, color="grey40", alpha=0.7) +
  facet_wrap(.~diagnostic_group) +
  theme_minimal() +
  ylab("WGBS Platform") +
  xlab("EPIC 850k Platform") +
  labs(caption = 
  "47 samples used. Both estimations use methylCC trained on 850k reference data.\nGray lines represent ideal fit (i.e. perfect concordance)") +
   theme(plot.caption = element_text(hjust = 0),
         plot.background = element_rect(fill="white",
                                        color="white")) +
  scale_color_npg()

print(p)

  
```


